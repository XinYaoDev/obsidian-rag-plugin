const esbuild = require("esbuild");
const process = require("process");
const builtins = require("builtin-modules");
const fs = require("fs");

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");

// 你的 Obsidian 插件目录
const outDir = "E:\\Obsidian\\KnowledgeBox\\.obsidian\\plugins\\my-rag-plugin\\";

function copyStaticFiles() {
    console.log(`Copying static files to ${outDir}...`);
    try {
        if (!fs.existsSync(outDir)) {
            fs.mkdirSync(outDir, { recursive: true });
        }
        fs.copyFileSync("manifest.json", outDir + "manifest.json");
        if (fs.existsSync("styles.css")) {
            fs.copyFileSync("styles.css", outDir + "styles.css");
        }
        console.log("Static files copied!");
    } catch (e) {
        console.error("Error copying static files:", e);
    }
}

// 因为 CommonJS 不支持顶层 await，所以我们需要用 async 函数包裹一下
(async () => {
    try {
        const context = await esbuild.context({
            banner: {
                js: banner,
            },
            entryPoints: ["main.ts"],
            bundle: true,
            external: [
                "obsidian",
                "electron",
                "@codemirror/autocomplete",
                "@codemirror/collab",
                "@codemirror/commands",
                "@codemirror/language",
                "@codemirror/lint",
                "@codemirror/search",
                "@codemirror/state",
                "@codemirror/view",
                "@lezer/common",
                "@lezer/highlight",
                "@lezer/lr",
                ...builtins
            ],
            format: "cjs",
            target: "es2018",
            logLevel: "info",
            sourcemap: prod ? false : "inline",
            treeShaking: true,
            outfile: outDir + "main.js",
            minify: prod,
        });

        copyStaticFiles();

        if (prod) {
            await context.rebuild();
            process.exit(0);
        } else {
            await context.watch();
        }
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
})();