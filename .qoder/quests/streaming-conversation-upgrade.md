# 流式对话升级设计文档

## 一、功能概述

将现有的"同步等待式"对话体验升级为"流式响应 (Server-Sent Events)"体验，实现 AI 回答的实时打字机效果和深度思考过程的实时展示，降低用户感知延迟。

## 二、目标与价值

### 核心目标

-   支持流式响应，AI 回答以打字机效果逐字展示
-   支持深度思考过程的实时流式输出
-   保持现有 UI 样式和交互体验
-   确保网络异常时的错误处理机制

### 用户价值

-   **降低感知延迟**: 用户可立即看到 AI 开始回答，而非等待完整响应
-   **实时思考展示**: 深度思考模式下，推理过程实时可见，提升透明度
-   **更好的体验**: 打字机效果带来更自然的对话节奏

## 三、后端接口协议

### 接口信息

| 属性             | 值                                     |
| ---------------- | -------------------------------------- |
| **端点**         | `POST /api/rag/chat/stream`            |
| **方法**         | POST                                   |
| **Content-Type** | application/json                       |
| **协议**         | Server-Sent Events (SSE) via HTTP POST |

### 请求结构

请求体保持与现有 `/api/rag/chat` 接口完全一致：

| 字段               | 类型    | 说明                 |
| ------------------ | ------- | -------------------- |
| question           | string  | 用户问题             |
| provider           | string  | LLM 服务商代码       |
| model              | string  | 模型名称             |
| history            | array   | 会话历史消息数组     |
| enableDeepThinking | boolean | 是否启用深度思考模式 |

### 响应事件流

后端通过 SSE 推送两种自定义事件：

#### 事件类型 A: thinking（深度思考）

```
event: thinking
data: 这是一段推理文字...
```

**触发条件**: `enableDeepThinking` 为 true 且模型支持深度思考

**前端行为**:

-   增量追加到当前 AI 消息气泡的思考面板（thinking-panel）
-   思考面板应处于展开或活跃状态
-   文字以流式方式逐步显示

#### 事件类型 B: answer（正式回答）

```
event: answer
data: 这是回答的一部分...
```

**前端行为**:

-   增量追加到当前 AI 消息气泡的主内容区域
-   呈现打字机效果
-   实时渲染 Markdown（包括代码块、公式等）

#### 结束标识

流可能通过以下方式结束：

-   发送 `data: [DONE]` 标识
-   直接关闭 Stream 连接

## 四、前端架构设计

### 4.1 模块划分

当前代码主要在 `chatView.ts` 中的 `sendMessage` 方法（第 302-388 行）处理对话请求，需重构为流式架构。

| 模块                | 职责                                    | 位置                         |
| ------------------- | --------------------------------------- | ---------------------------- |
| **流式请求层**      | 封装 SSE 请求逻辑、缓冲区处理、事件解析 | 新增独立方法或工具函数       |
| **UI 状态管理层**   | 管理 AI 消息占位符、增量更新内容        | `chatView.ts` 中扩展现有方法 |
| **Markdown 渲染层** | 实时渲染流式内容，避免闪烁              | 利用现有 `MarkdownRenderer`  |
| **错误处理层**      | 网络中断、超时、后端错误处理            | 扩展现有错误处理机制         |

### 4.2 流式请求核心逻辑

#### 技术要点

由于是 POST 请求且包含自定义 Header，**禁止使用浏览器原生 EventSource API**，必须使用 `fetch` + `ReadableStream`。

#### 缓冲区处理机制

SSE 数据可能因 TCP 分包导致一行数据被切断，必须实现缓冲区拼接：

**处理规则**:

-   按 `\n\n` 分割事件块
-   维护缓冲区字符串，累积未完成的行
-   解析完整事件块后提取 `event:` 和 `data:`

**伪代码流程**:

```
初始化缓冲区 buffer = ""

当收到数据块 chunk:
    buffer += chunk

    按 "\n\n" 分割 buffer:
        对于每个完整事件块:
            解析事件类型（thinking/answer）
            解析数据内容 data
            调用对应回调更新 UI

        保留最后不完整的部分到 buffer

当流结束:
    处理剩余 buffer 中的内容
```

#### 流式请求函数签名

```
函数名称: streamChat

参数:
- url: 请求地址
- requestBody: 请求体对象
- apiKey: API Key（放入 Header）
- onThinking: 回调函数，参数为 thinking 数据片段
- onAnswer: 回调函数，参数为 answer 数据片段
- onError: 回调函数，参数为错误对象
- onComplete: 回调函数，无参数

返回值:
- Promise，可用于 await 等待流结束
```

### 4.3 UI 状态管理设计

#### 消息占位符创建

用户点击发送后，立即执行以下操作：

1. 创建用户消息气泡（保持现有逻辑）
2. 创建一个空的 AI 消息占位符：
    - 初始状态显示 loading 图标
    - 包含思考面板占位区域（如果 `enableDeepThinking` 为 true）
    - 包含回答内容占位区域

#### 增量更新策略

**思考内容更新**:

-   维护内部字符串变量 `thinkingBuffer`
-   每次 `onThinking` 回调时，追加新数据到 `thinkingBuffer`
-   更新思考面板的 DOM 内容（使用 `MarkdownRenderer.render` 或纯文本追加）
-   思考面板默认展开状态

**回答内容更新**:

-   维护内部字符串变量 `answerBuffer`
-   每次 `onAnswer` 回调时，追加新数据到 `answerBuffer`
-   清空回答区域的旧内容，重新渲染完整的 `answerBuffer`
-   重新包裹代码块（调用现有 `wrapCodeBlocks` 方法）

**滚动行为**:

-   每次内容更新后，滚动消息容器到底部（`scrollTo({ top: scrollHeight, behavior: 'smooth' })`）

#### 状态转换流程

```mermaid
stateDiagram-x
    [*] --> 等待中: 用户点击发送
    等待中 --> 连接中: 发起流式请求
    连接中 --> 思考中: 收到 thinking 事件
    连接中 --> 回答中: 收到 answer 事件
    思考中 --> 回答中: 收到 answer 事件
    思考中 --> 思考中: 继续收到 thinking 事件
    回答中 --> 回答中: 继续收到 answer 事件
    回答中 --> 完成: 收到 [DONE] 或流结束
    思考中 --> 完成: 收到 [DONE] 或流结束
    连接中 --> 错误: 网络异常/超时
    思考中 --> 错误: 网络中断
    回答中 --> 错误: 网络中断
    错误 --> [*]: 显示错误提示
    完成 --> [*]: 保存会话历史
```

### 4.4 Markdown 实时渲染策略

#### 渲染时机

-   **触发频率控制**: 使用节流（throttle）机制，避免每次数据到达都重新渲染
    -   建议每 100-200ms 渲染一次
    -   或累积数据达到一定长度（如 50 字符）时渲染

#### 渲染方法

1. 清空目标 DOM 容器
2. 调用 `MarkdownRenderer.render(app, answerBuffer, container, '', this)`
3. 重新调用 `wrapCodeBlocks(container)` 添加代码块复制按钮
4. 如果是流式结束时的最后一次渲染，添加全文复制按钮

#### 闪烁防护

-   使用 CSS `transition` 平滑内容变化
-   代码块在未完整时可能解析失败，需捕获渲染异常并降级为纯文本
-   考虑在流式过程中隐藏全文复制按钮，待流结束后再显示

### 4.5 错误处理设计

#### 错误分类

| 错误类型      | 检测方式                     | 处理策略                                   |
| ------------- | ---------------------------- | ------------------------------------------ |
| **连接失败**  | fetch 抛出异常（网络不可达） | 移除 loading，显示错误气泡，执行撤回逻辑   |
| **HTTP 错误** | response.ok 为 false         | 读取错误响应体，显示后端错误信息           |
| **流中断**    | Stream 意外关闭              | 保留已接收内容，显示"连接中断"提示         |
| **超时**      | 设定超时定时器（如 60 秒）   | 中止请求，显示超时错误                     |
| **解析错误**  | SSE 数据格式异常             | 记录错误日志，跳过异常块，继续处理后续数据 |

#### 撤回机制

沿用现有失败撤回逻辑（`rollbackFailedMessage` 方法）：

-   移除用户消息气泡
-   从会话历史中删除用户消息
-   恢复输入框内容

#### 错误提示 UI

-   在 AI 消息气泡中显示错误信息（使用 `error` 样式类）
-   提供重试指引（如"请检查网络连接后重试"）

## 五、会话历史存储策略

### 存储内容

-   **思考内容**: 不存储到会话历史（与现有逻辑一致）
-   **回答内容**: 仅存储最终完整的 `answerBuffer`

### 存储时机

-   流式响应完成（收到 `[DONE]` 或流正常结束）时
-   调用 `sessionManager.addMessage({ role: 'assistant', content: answerBuffer })`
-   调用 `sessionManager.saveSession()`

### 异常情况处理

-   如果流中断但已接收部分内容，可选择：
    -   方案 A（推荐）: 不保存到历史，清空气泡，提示用户重试
    -   方案 B: 保存已接收部分，标记为"不完整回答"

## 六、UI 样式兼容性

### 现有样式保持不变

-   代码块 Header Bar 布局（语言标签 + 复制按钮）
-   全文复制按钮位置（AI 气泡左下角）
-   思考面板折叠/展开交互
-   错误消息样式（红色边框）

### 流式特有样式需求

#### 打字机光标效果（可选）

在流式输出过程中，可在内容末尾添加闪烁光标：

-   使用 CSS 动画实现
-   流结束后移除

#### 思考面板活跃状态（可选）

在接收 `thinking` 事件期间：

-   添加特殊样式类（如 `thinking-panel--active`）
-   显示脉冲动画或进度指示器
-   流结束后移除

## 七、实现步骤建议

### 阶段一：基础流式能力

1. 封装 `streamChat` 流式请求函数
2. 实现 SSE 缓冲区解析逻辑
3. 修改 `sendMessage` 方法，创建占位符并调用流式请求
4. 实现 `onAnswer` 回调，增量更新回答内容

### 阶段二：深度思考支持

5. 实现 `onThinking` 回调，增量更新思考面板
6. 确保思考面板在流式过程中保持展开状态
7. 测试思考和回答同时流式输出的场景

### 阶段三：错误处理与优化

8. 实现网络异常、超时、中断的错误处理
9. 添加渲染节流优化，避免频繁重绘
10. 测试各种边界场景（长文本、代码块、公式）

### 阶段四：验收测试

11. 验证打字机效果是否流畅
12. 验证思考过程实时展示
13. 验证错误提示是否清晰
14. 验证现有 UI 样式不受影响

## 八、风险与注意事项

### 技术风险

| 风险                              | 缓解措施                                 |
| --------------------------------- | ---------------------------------------- |
| **TCP 分包导致数据不完整**        | 实现严格的缓冲区拼接逻辑，按 `\n\n` 分割 |
| **Markdown 渲染频繁导致性能问题** | 使用节流控制渲染频率                     |
| **代码块未完整时渲染失败**        | 捕获异常，降级为纯文本显示               |
| **长时间无数据导致超时误判**      | 设置合理超时阈值（60 秒以上）            |

### 兼容性注意

-   确保现有的复制按钮功能不受影响
-   确保思考面板折叠状态在流式过程中正确
-   确保会话管理功能（切换、删除、清空）不受影响

### 用户体验注意

-   流式过程中禁用发送按钮，避免重复请求
-   提供明确的"正在生成"状态指示
-   网络慢时避免长时间无反馈，可显示"连接中..."提示

## 九、验收标准

### 功能验收

-   [ ] 能够同时看到思考过程和回答内容实时生成
-   [ ] 打字机效果流畅，无明显卡顿
-   [ ] Markdown 渲染正常（代码块、公式、列表等）
-   [ ] 网络异常时有清晰错误提示，不会无限 loading
-   [ ] 错误后能正确执行撤回，用户可重新发送

### UI 验收

-   [ ] 现有样式保持不变（复制按钮、头像、颜色等）
-   [ ] 思考面板在流式过程中正常展开/收起
-   [ ] 代码块 Header Bar 正常显示语言标签和复制按钮
-   [ ] 全文复制按钮在流结束后正常显示

### 性能验收

-   [ ] 长文本（1000+ 字）流式输出无明显延迟
-   [ ] 多个代码块同时渲染不会卡顿
-   [ ] 浏览器控制台无异常错误日志

## 十、后续优化方向

### 短期优化

-   添加流式速度控制（模拟打字速度，避免过快）
-   支持用户手动中止流式输出
-   优化长代码块的渲染性能

### 长期演进

-   支持流式输出中的实时搜索高亮
-   支持多模态流式（图片、表格等）
-   支持离线缓存流式响应

---

**设计完成日期**: 2025-12-06  
**设计版本**: v1.0**设计完成日期**: 2025-12-06
